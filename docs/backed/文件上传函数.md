uni.uploadFile只支持单文件，上传多文件需要循环调用

# 单文件上传

```javascript
//单张图片直接使用一下代码，一般用于头像上传
uni.chooseImage({
  success: (chooseImageRes) => {
    const tempFilePaths = chooseImageRes.tempFilePaths;
    uni.uploadFile({
      url: "https://www.example.com/upload", //仅为示例，非真实的接口地址
      filePath: tempFilePaths[0], // 指定文件路径
      name: "file", // 后端接收的字段名
      formData: {
        // 额外的表单数据
        user: "test",
      },
      success: (uploadFileRes) => {
        console.log(uploadFileRes.data);
      },
    });
  },
});
```

```js
export function requestWithFiles(config = {}) {
  // ==================== 第一步：参数解构和初始化 ====================
  // 从配置对象中解构参数，并设置默认值
  const {
    url = "", // API 路径，默认空字符串
    files = [], // 文件数组，默认空数组
    data = {}, // 表单数据，默认空对象
    headers = {}, // 自定义请求头，默认空对象
  } = config;

  // ==================== 第二步：获取用户认证 Token ====================
  // 声明 accessToken 变量，用于存储从缓存中读取的 Token
  let accessToken = null;
  // 从 uni-app 本地缓存中同步获取用户信息（JSON 字符串格式）
  const userInfoStr = uni.getStorageSync("userInfo");

  if (userInfoStr) {
    // 将 JSON 字符串解析为对象
    const userInfo = JSON.parse(userInfoStr);

    // 使用可选链操作符 ?. 安全地获取 access_token
    // 如果 userInfo 为 null/undefined，或不存在 access_token 属性，则返回 undefined
    accessToken = userInfo?.access_token;
  }

  // ==================== 第三步：构建请求头 ====================
  // 合并自定义 headers 和认证信息
  const requestHeaders = {
    ...headers, // 展开用户传入的自定义请求头
    // 添加 Authorization 字段，将 Token 放入请求头
    // 格式：Authorization: <token>
    Authorization: `${accessToken}`,
  };

  // ==================== 第四步：返回 Promise 对象 ====================
  // 使用 Promise 包装异步上传操作，便于调用方使用 async/await 或 .then/.catch
  return new Promise((resolve, reject) => {
    // ==================== 分支 A：无文件上传，降级为普通 POST 请求 ====================
    // 如果没有传入文件，或文件数组为空
    if (!files || files.length === 0) {
      // 调用普通的 request 函数（POST 方法）
      // 直接将 Promise 的 resolve 和 reject 传递过去
      return request({
        url, // 使用相同的 URL
        method: "POST", // 强制使用 POST 方法
        data, // 传递表单数据
        headers: requestHeaders, // 传递构建好的请求头（包含 Token）
      })
        .then(resolve) // 成功时调用外层 Promise 的 resolve
        .catch(reject); // 失败时调用外层 Promise 的 reject
    }

    // ==================== 分支 B：有文件上传，使用 uni.uploadFile ====================
    // uni.uploadFile API 说明：
    // - uni-app 提供的文件上传 API
    // - 只支持单文件上传（name 对应一个文件）
    // - 使用 multipart/form-data 格式
    // - 可以同时携带其他表单数据（通过 formData）

    // 重要限制：uni.uploadFile 只支持单文件
    // 如果 files 数组有多个文件，这里只会上传第一个文件 files[0]
    uni.uploadFile({
      // ---------- 上传配置参数 ----------
      // 完整的上传 URL = BASE_URL + 相对路径
      url: BASE_URL + url,

      // 文件路径提取逻辑：
      // 1. 如果 files[0] 是字符串，直接使用
      // 2. 如果是对象，尝试取 path 属性
      // 3. 如果都没有，使用 files[0] 本身
      // 三元运算符嵌套：
      //   - 第一层：typeof files[0] === "string" ? 直接用 : 不是字符串
      //   - 第二层：files[0].path || files[0]（取 path 或本身）
      filePath:
        typeof files[0] === "string"
          ? files[0] // files[0] 是字符串，直接使用
          : files[0].path || files[0], // files[0] 是对象，取 path 属性或整个对象

      // 后端接收的字段名称
      // 后端通过 req.files['images'] 获取上传的文件
      name: "images",

      // 额外的表单数据（会和文件一起作为 multipart/form-data 发送）
      // 后端可以通过 req.body 获取这些字段
      formData: {
        ...data, // 展开用户传入的 data 对象
      },

      // 请求头（包含认证 Token）
      header: requestHeaders,

      // ---------- 上传成功回调 ----------
      success: (res) => {
        // 检查 HTTP 状态码
        if (res.statusCode === 200) {
          // ========== 响应数据解析 ==========
          // uni.uploadFile 返回的 res.data 是字符串类型
          // 需要手动解析为 JSON 对象
          try {
            // 检查 res.data 类型：
            // - 如果是字符串，使用 JSON.parse 解析
            // - 如果已经是对象，直接使用
            const result =
              typeof res.data === "string"
                ? JSON.parse(res.data) // 字符串 -> 对象
                : res.data; // 已经是对象

            // 将解析后的结果传递给外层 Promise 的 resolve
            resolve(result);
          } catch (error) {
            // 如果 JSON 解析失败（后端返回的不是合法 JSON）
            // 直接将原始数据返回
            // 注意：这里是 resolve 而不是 reject，表示上传成功但数据格式异常
            resolve(res.data);
          }
        } else {
          // ========== HTTP 状态码不是 200，表示上传失败 ==========

          // 使用错误信息格式化函数统一处理错误消息
          // 优先级：res.data.detail > res.data.message > "上传失败"
          const errorMessage = formatErrorMessage(
            res.data?.detail || res.data?.message || "上传失败"
          );

          // 向用户显示错误提示
          uni.showToast({
            title: errorMessage, // 错误消息
            icon: "none", // 不显示图标（纯文字提示）
            duration: 3000, // 显示 3 秒
          });

          // 调用外层 Promise 的 reject，传递 Error 对象
          reject(new Error(errorMessage));
        }
      },

      // ---------- 上传失败回调 ----------
      // 当网络错误、文件路径错误等导致上传无法进行时触发
      fail: (err) => {
        // 打印详细的错误信息到控制台，便于调试
        console.error("上传失败:", err);

        // 调用外层 Promise 的 reject
        // 直接传递 err 对象（包含了详细的失败信息）
        reject(err);
      },
    });
  });
}
```

# 默认使用并行上传

同时发起所有文件的上传请求，速度快；但对服务器并发压力较大（反正没人用），注意默认并行上限是10个

## 思路

1. 使用 map 创建 Promise 数组
   假设 files = ['图片1.jpg', '图片2.jpg', '图片3.jpg']

```js
// map 遍历后生成：
uploadPromises = [
  Promise { <pending> },  // 上传图片1的 Promise
  Promise { <pending> },  // 上传图片2的 Promise
  Promise { <pending> }   // 上传图片3的 Promise
]
```

2. 使用resolve来批量获取所有上传结果，防止中断
3. 因为所有文件的请求头是一致的，所以不需要循环调用
